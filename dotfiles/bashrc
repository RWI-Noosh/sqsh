# Needed for funky stuff like changing HOME for certain hosts.
[ -e $HOME/.bashrc.pre ] && . $HOME/.bashrc.pre

export CLICOLOR=1
export EDITOR=vim
export HISTFILESIZE=10000
export HISTSIZE=10000
export HISTIGNORE="&:[ ]*:exit:l:ll:ls:histdel"
export LC_ALL="en_US.UTF-8"
export LESS="-# 60 -i -X -R"
export LSCOLORS=dxfxcxdxbxegedabagacad
export LS_COLORS='di=1;35:ln=35:ex=31:su=30;43:sg=30;43:tw=30;43:ow=30;43:'
export PAGER=less
export PATH=$HOME/bin:$HOME/code/go/bin:/usr/local/bin:$PATH
export TERM=xterm-256color
export VISUAL=vim
export PYTHONSTARTUP=$HOME/.pythonrc
export PYTHONPATH=.:$HOME/code/python
export GREP_OPTIONS="-P --color=auto"
export GOPATH=$HOME/code/go

alias l='ls'
alias ll='ls -l'
alias j='jobs'
alias ocaml='ledit -x -h ~/.ocaml_history ocaml'
alias full='sudo xrandr --output default --mode 1920x1080'
alias small='sudo xrandr --output default --mode 800x600'
alias irssi='TERM=screen-256color irssi'
alias resolve="vim \$(git status -s | awk '/^(UU|AA)/ { print \$2}')"

ulimit -S -n 4096

shopt -s histappend checkwinsize cmdhist extglob
if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
    shopt -s globstar
fi
set show-all-if-ambiguous on
set +H # history substitution is evil
if [[ "$-" == *i* ]]; then # interactive
    bind "\C-p":history-search-backward
    bind "\C-n":history-search-forward
fi

# Try to disable flow control
[ -t 0 ] && stty -ixon -ixoff


function gitBranch {
    branch_name=$(git symbolic-ref -q HEAD 2>/dev/null || true)
    branch_name=${branch_name##refs/heads/}
    branch_name=${branch_name:--}
    echo $branch_name
}

function gitTrackingBranch {
    git rev-parse --symbolic-full-name --abbrev-ref @{upstream}
}


function prompt1 {
    local y="\[\e[33m\]" # yellow
    local g="\[\e[32m\]" # green
    local orig="\[\e[0m\]"
    PS1="$g($y\$?$g)$y\$(date +%H:%M)$g:$y\w $g($y\$(gitBranch)$g)$g\$$orig "
}
prompt1

# cd to a directory further up your path that contains the given pattern.
# Change to the parent directory if nothing given.
# eg, if pwd is /usr/local/bin, then running "up loc" will cd to /usr/local.
function up {
  if [[ "$1" != "" ]]; then
    cd $(echo "$PWD" | perl -pe "s#(.*$1[^/]*/).*#\1#i;")
  else
    cd ..
  fi
}

# usage: mrm pattern n
# Print the nth most-recently-modified filename that matches pattern. If
# pattern is a glob you'll probably want to quote it.
function mrm {
    local pattern=${1:?No pattern given.}; shift
    local n=${1:-1}; shift
    ls -1dt $pattern | sed -n -e "${n}p"
}

# emrm vim session*.log [n]
function emrm {
    local prog=${1:?No prog given.}; shift
    local pattern=${1:?No pattern given.}; shift
    local n=${1:-1}; shift
    $prog $(mrm "$pattern" $n);
}

# view most recently modified
# eg, to view the second most recent "io" log: vmrm 'io.log*' 2
function vmrm {
    local pattern=${1:?No pattern given.}; shift
    local n=${1:-1}; shift
    $PAGER $(mrm "$pattern" $n);
}

# Delete last command from history: histdel
# Delete from offset to end of history: histdel OFFSET
# Delete from offset to another offset: histdel OFFSET OFFSET
function histdel {
    local last=$(history | tail -n 1 | awk '{print $1}')
    local start=${1:-$last}
    local end=${2:-$((last+1))}
    while [[ $start -lt $end ]]; do
        history -d $start
        end=$((end-1))
    done
}

# screen attach
function sat {
    local hostname=${1:-localhost}
    if [[ "$hostname" == localhost ]]; then
        screen -xRR
    else
        ssh -t $hostname screen -xRR
    fi
}

# git submodule update
function gsu {
    repoRoot=$(git rev-parse --show-toplevel)
    # execute in a subshell so we don't have to save the cwd
    (cd $repoRoot; git submodule update)
}

# consider using ssh-copy-id instead
function send_key {
    ssh $1 "echo $(cat $HOME/.ssh/id_rsa.pub) >> ~/.ssh/authorized_keys "
}

# find files under current directory containing a pattern
function ff {
    pattern=${1:?No pattern given}
    find . -iname "*${pattern}*" 2>/dev/null
}

# filesystem bookmarks
# create: bm c NAME PATH
# list: bm l
# goto: bm g NAME
function bm {
    local cmd=${1:-l}; shift
    local rc=${BMRC:-~/.bmrc}
    case $cmd in
        l) cat $rc;;
        c)
            local name=${1:?No name given.}; shift
            local path=${1:-$PWD}
            echo "$name $path" >> $rc
            ;;
        g)
            local name=${1:?No name given.}; shift
            cd $(awk "\$1 == \"$name\" {print \$2}" $rc)
            ;;
        *)
            echo "Bad command: $cmd"
            return 1
            ;;
    esac
}
alias g="bm g"

# tab completion for select programs, since loading everything takes too long,
# especially over nfs.
[ -e $HOME/.bash_completion.sh ] && . $HOME/.bash_completion.sh

[ -e $HOME/.bashrc.local ] && . $HOME/.bashrc.local
