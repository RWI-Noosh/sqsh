filetype plugin indent on
" vimball doesn't load properly with older versions of vim.
let g:pathogen_disabled = ['vimball', 'command-t',]
call pathogen#helptags()
call pathogen#runtime_append_all_bundles()

" highlight lines over 120 characters
"highlight OverLength ctermbg=red ctermfg=white guibg=#592929
"match OverLength /\%>121v.\+/

let mapleader = 's'

set laststatus=2 ruler
set sts=4 ts=4 sw=4 et
set ai
set ic hls smartcase incsearch
set showmatch mat=2
set wim=list:longest
set backup
set grepprg=ag
set bs=2
set complete=.,w

nn Y y$
ino jk <esc>

syntax enable

set guioptions='cM'
set t_Co=16
set background=dark
colorscheme solarized

cnoremap <C-S>      <C-D>
cnoremap <C-A>		<Home>
cnoremap <C-B>		<Left>
cnoremap <C-D>		<Del>
cnoremap <C-E>		<End>
cnoremap <C-F>		<Right>
cnoremap <C-N>		<Down>
cnoremap <C-P>		<Up>

nn <leader>j :cn<cr>
nn <leader>k :cp<cr>
nn <leader>p :set paste!<cr>
nn <leader>h :noh<cr>
nn <leader>n :wn<cr>
nn <leader>N :N<cr>
nn <leader>ve :e ~/.vimrc<cr>
nn <leader>vn :new ~/.vimrc<cr>
nn <leader>vs :source ~/.vimrc<cr>
nn <leader> <nop>

" example of evaluating code on the command line
" also <c-r>=
"cno $c e <C-\>eCurrentFileDir("e")<cr>

function! SilentMake(...)
    if a:0 >= 1
        execute "silent! make! " . a:1
    else
        silent! make!
    endif
    redraw!
endfunction
com! -nargs=? Ma call SilentMake(<f-args>)

function! AppendTemplate(template, start, end)
    let l:i = a:start
    while l:i < a:end
        let l:current_line = substitute(a:template, '%d', l:i, "g")
        call append(".", l:current_line)
        call cursor(line(".")+1, 0)
        let l:i = l:i + 1
    endwhile
endfunction

let g:CommandTMaxHeight = 20

" Set the quickfix list to chunks of changes as shown by git diff.
" Passes its arguments straight to git diff, so by default it diffs the working
" directory with HEAD.
" Sets the first non-empty changed line as the description, if possible.
function! SetGitDiffAsQuickFixList(...)
    let command = "git diff -U0 " . join(a:000)
    let lines = split(system(command), '\n')
    " Relative paths would be nice but absolute paths are far easier.
    let repoRoot = util#trim(system("git rev-parse --show-toplevel"))
    let file = ''
    let locList = []
    let i = 0
    while i < len(lines)
        let line = lines[i]
        if match(line, '^diff') != -1
            let file = repoRoot .  '/' . matchlist(line, '\v b/(.*)$')[1]
        elseif match(line, '^@@') != -1
            let lineNum = matchlist(line, '\v.* \+(\d*)')[1]
            let descIndex = i + 1
            while len(lines[descIndex]) == 1 && descIndex < len(lines) - 1
                let descIndex += 1
            endwhile
            if match(lines[descIndex], '^diff\|^@@') != -1
                let descIndex = i + 1
            endif
            call add(locList, {'filename': file, 'lnum': lineNum, 'text': lines[descIndex]})
        endif
        let i += 1
    endwhile
    call setqflist(locList)
endfunction
command! -nargs=* Gdqf call SetGitDiffAsQuickFixList('<args>')

function! SourceRange() range
    let tmpsofile = tempname()
    call writefile(getline(a:firstline, a:lastline), l:tmpsofile)
    execute "source " . l:tmpsofile
    call delete(l:tmpsofile)
endfunction
command! -range Source <line1>,<line2>call SourceRange()

" Fill the quick-fix list with pylint output. Run pylint on the current file.
function! Pylint()
    let &l:makeprg = "pylint -f parseable -i y -r n %"
    let &l:efm = "%f:%l: %m"
    make!
endfunction
command! Pl call Pylint()

function! GitTrailingWhitespace(...)
    let prefix = util#trim(system("git rev-parse --show-prefix"))
    let &l:makeprg = "git diff --check " . join(a:000)
    let &l:efm = prefix . "%f:%l: %m"
    make!
endfunction
command! -nargs=* Gtw call GitTrailingWhitespace('<args>')

" Fill the quick-fix list with pylint output. Run pylint on all the files
" changed since the last commmit (default) or between given revisions, which
" are passed straight to git diff.
function! PylintGit(...)
    let command = "git diff --name-only " . join(a:000)
    let pathsFromRepoRoot = split(system(command), "\n")
    let prefixLength = strlen(util#trim(system("git rev-parse --show-prefix")))
    let paths = []
    for path in pathsFromRepoRoot
        call add(paths, strpart(path, prefixLength))
    endfor
    let &l:makeprg = "pylint -f parseable -i y -r n " . join(paths, ' ')
    let &l:efm = "%f:%l: %m"
    make!
endfunction
command! -nargs=* Pg call PylintGit('<args>')

function! UnitTestFilepath(fullpath)
    let testFilename = substitute(a:fullpath, '/yycli/', '/yycli/testHarness/unitTests/', '')
    let testFilename = substitute(testFilename, '[^/]*$', 'test_&', '')
    return testFilename
endfunction
nn <Leader>uts :exec ":sp " . UnitTestFilepath(expand('%:p'))<CR>
nn <Leader>utv :exec ":vsp " . UnitTestFilepath(expand('%:p'))<CR>

let g:pyflakes_use_quickfix = 0

let g:ctrlp_max_files = 90000

" CtrlP settings.
"nn <leader>f :CtrlP<cr>
"nn <leader>b :CtrlPBuffer<cr>
"nn <leader>m :CtrlPMRUFiles<cr>
"let g:ctrlp_custom_ignore = {
"    \ 'dir':  '\.git$\|\.hg$\|\.svn$\|_build',
"    \ 'file': '\.exe$\|\.so$\|\.dll$\|\~$',
"    \ }
"let g:ctrlp_lazy_update = 0
"let g:ctrlp_clear_cache_on_exit = 0
"let g:ctrlp_working_path_mode = 0
"let g:ctrlp_custom_ignore = '\~$'
" TC extension
"let g:ctrlp_extensions = ['tc']
"command! CtrlPTc call ctrlp#init(ctrlp#tc#id())
"nn <leader>t :CtrlPTc<cr>
"let g:ctrlp_prompt_mappings = {
"    \ 'PrtBS()':              ['<bs>', '<c-]>'],
"    \ 'PrtDelete()':          ['<del>'],
"    \ 'PrtDeleteWord()':      ['<c-w>'],
"    \ 'PrtClear()':           ['<c-u>'],
"    \ 'PrtSelectMove("j")':   ['<c-j>', '<c-n>'],
"    \ 'PrtSelectMove("k")':   ['<c-k>', '<c-p>'],
"    \ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
"    \ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
"    \ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
"    \ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
"    \ 'PrtHistory(-1)':       [],
"    \ 'PrtHistory(1)':        [],
"    \ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
"    \ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
"    \ 'AcceptSelection("t")': ['<c-t>'],
"    \ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
"    \ 'ToggleFocus()':        ['<s-tab>'],
"    \ 'ToggleRegex()':        ['<c-r>'],
"    \ 'ToggleByFname()':      ['<c-d>'],
"    \ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
"    \ 'ToggleType(-1)':       ['<c-b>', '<c-down>'], "    \ 'PrtExpandDir()':       ['<tab>'], "    \ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
"    \ 'PrtInsert()':          ['<c-\>'],
"    \ 'PrtCurStart()':        ['<c-a>'],
"    \ 'PrtCurEnd()':          ['<c-e>'],
"    \ 'PrtCurLeft()':         ['<c-b>', '<left>', '<c-^>'],
"    \ 'PrtCurRight()':        ['<c-f>', '<right>'],
"    \ 'PrtClearCache()':      ['<F5>'],
"    \ 'PrtDeleteEnt()':       ['<F7>'],
"    \ 'CreateNewFile()':      ['<c-y>'],
"    \ 'MarkToOpen()':         ['<c-z>'],
"    \ 'OpenMulti()':          ['<c-o>'],
"    \ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
"    \ }


function! WwnToVplex() range
    exe printf("%d,%ds/\\v([0-9a-f]{2}:){7}/\\='0x' . substitute(submatch(0), ':', '', 'g')/g", a:firstline, a:lastline )
endfunction

" Globally replace the word under the cursor with something else.
":nn <leader>r :exec printf('%%s#\<%s\>#self.%s#g', expand('<cword>'), expand('<cword>'))<cr>

nn <leader>x :source ~/source.vim<cr>
command! ProbeFindTc :cal probe#open(
    \ function('probe#tc#scan'),
    \ function('probe#tc#open'),
    \ function('probe#tc#refresh'))

nn <leader>q :ProbeFindTc<cr>
let g:probe_ignore_files = ['\~$', '_build']

nn <leader>d :ProbeFindFile<cr>

let g:ConqueTerm_CWInsert = 1
