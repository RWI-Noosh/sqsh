let g:pathogen_disabled = []
call pathogen#infect()

" Basics
" ======
filetype plugin on
set tags+=.tags
set laststatus=2 ruler
set sts=4 ts=4 sw=4 et
set ic hls smartcase incsearch
set showmatch matchtime=2  " paren-matching
set wim=list:longest
set grepprg=ag\ --nogroup\ --nocolor\ --column
"set grepprg=cfind\ -n
set bs=2
set complete=.,w  " stay fast by only suggesting completions from open windows
set winminheight=0
set modeline
set backup
" Make sure ~/tmp/vim exists.
set backupdir=~/tmp/vim,.
ino jk <esc>
let mapleader = 's'
set vb t_vb=
nn <leader> <nop>

" Display
syntax enable
set guioptions='cM'
set t_Co=16
set background=dark
colorscheme solarized

" Emacs emulation in Cmdline mode.
cnoremap <C-S>      <C-D>
cnoremap <C-A>		<Home>
cnoremap <C-B>		<Left>
cnoremap <C-D>		<Del>
cnoremap <C-E>		<End>
cnoremap <C-F>		<Right>
cnoremap <C-N>		<Down>
cnoremap <C-P>		<Up>

" Quickfix
nn <leader>j :cn<cr>
nn <leader>k :cp<cr>

" Arglist
nn <leader>n :wn<cr>
nn <leader>N :N<cr>

" vimrc
nn <leader>ve :e ~/.vimrc<cr>
nn <leader>vn :new ~/.vimrc<cr>
nn <leader>vs :source ~/.vimrc<cr>

" Various conveniences
nn <leader>p :set paste!<cr>
nn <leader>h :noh<cr>
nn <leader>g :grep <cword><cr>
" remove trailing whitespace
nn <leader>mw :%s/\v\s+$//<cr>
nn <leader>ms :w<cr>:source %<cr>
nn <leader>x :source ~/source.vim<cr>

nn Y y$

" Indenting
" =========
" One indenting expression to rule them all.
"
" Cover common cases but let the user take care of anything weird, since
" trying to be comprehensive complicates the rules past predictability.
function! TorbijIndent()
    let prev_line = getline(v:lnum - 1)
    let prev_indent = indent(v:lnum - 1)
    let cur_line = getline(v:lnum)
    let inc = 0
    let dec = 0
    for p in g:inc_indent_after
        if prev_line =~ p
            let inc += &sw
            break
        endif
    endfor
    for p in g:dec_indent_on
        if cur_line =~ p
            let dec += &sw
            break
        endif
    endfor
    if inc == 0 && dec == 0
        return -1  " Defer to autoindent.
    endif
    return prev_indent + inc - dec
endfunction

" If the previous line matches one of these patterns, increment the indent of
" the next line.
let g:inc_indent_after = [
    \ '[{\[\(:]$',
    \ '^function ',
    \ '^\v\s*(if|else|while|do|for|switch|elseif) '
\ ]
" If the current line matches one of these patterns, decrement its indent.
" Depends on indentkeys being set appropriately.
let g:dec_indent_on = ['^\s*[}\]\)]', '^\s*end']

set indentexpr=TorbijIndent()
set indentkeys=0},0],0),o,O,0=end
set ai nosi nocin
filetype indent off


" Functions
" =========
function! SourceRange() range
    let tmpsofile = tempname()
    call writefile(getline(a:firstline, a:lastline), l:tmpsofile)
    execute "source " . l:tmpsofile
    call delete(l:tmpsofile)
endfunction
command! -range Source <line1>,<line2>call SourceRange()

command! -range=% Copy silent <line1>,<line2>w !xsel -i
nn <leader>c :Copy<cr>
vn <leader>c :Copy<cr>

function! AppendDate()
    cal setline('.', getline('.') . util#trim(system('date "+%F %A"')))
endfunction
nn <leader>md :cal AppendDate()<cr>

function! WwnToVplex() range
    exe printf("%d,%ds/\\v([0-9a-f]{2}:){7}/\\='0x' . substitute(submatch(0), ':', '', 'g')/g", a:firstline, a:lastline )
endfunction

function! WwnToColon() range
    exe printf("%d,%ds/\\v0x([0-9a-f]{16})/\\=join(split(submatch(1), '..\\zs'), ':')", a:firstline, a:lastline )
endfunction

command! -nargs=? Filter let @g = '' | execute 'g/<args>/y G' | let @g = @g[1:]

" split: 'none', 'split', 'vsplit'
function! OpenOrReuse(filepath, split)
    let buffer_name = a:filepath
    let window = bufwinnr(buffer_name)
    if window != -1
        exe printf('%dwincmd w', window)
    else
        exe printf('silent! %s %s', a:split, buffer_name)
    endif
endfunction

function! QFComment(comment_file)
    let filepath = expand('%')
    let lnum = line('.')
    let prefix = join([filepath, lnum], ':') . ': '
    cal OpenOrReuse(a:comment_file, 'split')
    if getline(1, '$') == ['']
        cal setline(1, prefix)
    else
        cal append(line('$'), prefix)
    endif
    normal G$
endfunction
command! -nargs=? -complete=file QFComment cal QFComment(<f-args>)
nn <leader>mc :QFComment ~/tmp/comments<cr>

" Idempotent table formatter.
" sep: field separator pattern
" opts: dict with the following keys:
"   align: string of field alignments (eg. "llr" for Left, Left, Right)
"   newsep: new separator. Useful if regex metacharacters are present in sep.
function! Table(sep, opts) range
    let alignment = split(get(a:opts, 'align', ""), '\zs')
    let max_len = {}
    for line in getline(a:firstline, a:lastline)
        for [i, field] in util#enumerate(split(line, a:sep))
            let field = util#trim(field)
            let max_len[i] = max([get(max_len, i, 0), strlen(field)])
        endfor
    endfor
    let formatted = []
    for line in getline(a:firstline, a:lastline)
        let fields = []
        for [i, field] in util#enumerate(split(line, a:sep))
            let field = util#trim(field)
            if get(alignment, i, 'l') == 'l'
                let format = printf('%%-%ds', max_len[i])
            else
                let format = printf('%%%ds', max_len[i])
            endif
            cal add(fields,  printf(format, field))
        endfor
        cal add(formatted, join(fields, get(a:opts, 'newsep', a:sep)))
    endfor
    cal setline(a:firstline, formatted)
endfunction
nn <leader>mt :normal! vip:cal Table('  \+', {'newsep': '  '})
vn <leader>mt :cal Table('  \+', {'newsep': '  '})<cr>

" Make script-local function global.
function! Public(function_name)
    let groups = matchlist(a:function_name, '\v^(<SID>|s:)(.*)')
    let prefix = groups[1]
    let basename = groups[2]
    exe printf('%%s/%s/\u%s/g', a:function_name, basename)
endfunction
nn sme :cal Public(expand('<cword>'))<cr>

" Hide global function by making it script-local.
function! Private(function_name)
    exe printf('%%s/\<%s\>/s:\l&/g', a:function_name)
endfunction
nn smh :cal Private(expand('<cword>'))<cr>


" Plugin configuration
" ====================
let g:ConqueTerm_CWInsert = 1
let g:NERDTreeDirArrows=0
let g:pyflakes_use_quickfix = 0
let g:CommandTMaxHeight = 20

let g:syntastic_mode_map = {'mode': 'passive'}
let g:syntastic_python_checkers = ['flake8']

" Probe
let g:probe_ignore_files = ['\~$', '_build', 'pyc$']
command! ProbeFindTc :cal probe#open(
    \ function('probe#tc#scan'),
    \ function('probe#tc#open'),
    \ function('probe#tc#refresh'))
nn <leader>mq :ProbeFindTc<cr>
nn <leader>d :ProbeFindFile<cr>
nn <leader>f :ProbeFindInRepo<cr>

" Make pyflakes highlighting more visible
highlight clear SpellBad
highlight link SpellBad ErrorMsg


" Compilers
" =========
function! Pylint()
    let &l:makeprg = "pylint -f parseable -i y -r n %"
    let &l:efm = "%f:%l: %m"
    make!
endfunction
command! Pl call Pylint()

function! RBCheck()
    let saved_makeprg = &makeprg
    let &makeprg = 'rb_check'
    make
    let &makeprg = saved_makeprg
endfunction
nn <leader>mr :cal RBCheck()<cr>

function! Pep()
    let saved_makeprg = &makeprg
    let &makeprg = 'pep'
    make %
    let &makeprg = saved_makeprg
endfunction
nn <leader>mp :cal Pep()<cr>

function! GitTrailingWhitespace(...)
    let prefix = util#trim(system("git rev-parse --show-prefix"))
    let &l:makeprg = "git diff --check " . join(a:000)
    let &l:efm = prefix . "%f:%l: %m"
    make!
endfunction
command! -nargs=* Gtw call GitTrailingWhitespace('<args>')

" Fill the quick-fix list with pylint output. Run pylint on all the files
" changed since the last commmit (default) or between given revisions, which
" are passed straight to git diff.
function! PylintGit(...)
    let command = "git diff --name-only " . join(a:000)
    let pathsFromRepoRoot = split(system(command), "\n")
    let prefixLength = strlen(util#trim(system("git rev-parse --show-prefix")))
    let paths = []
    for path in pathsFromRepoRoot
        call add(paths, strpart(path, prefixLength))
    endfor
    let &l:makeprg = "pylint -f parseable -i y -r n " . join(paths, ' ')
    let &l:efm = "%f:%l: %m"
    make!
endfunction
command! -nargs=* Pg call PylintGit('<args>')

" Set the quickfix list to chunks of changes as shown by git diff.
" Passes its arguments straight to git diff, so by default it diffs the working
" directory with HEAD.
" Sets the first non-empty changed line as the description, if possible.
function! QuickfixGitDiff(...)
    let command = "git diff -U0 " . join(a:000)
    let lines = split(system(command), '\n')
    " Relative paths would be nice but absolute paths are far easier.
    let repoRoot = util#trim(system("git rev-parse --show-toplevel"))
    let file = ''
    let locList = []
    let i = 0
    while i < len(lines)
        let line = lines[i]
        if match(line, '^diff') != -1
            let file = repoRoot .  '/' . matchlist(line, '\v b/(.*)$')[1]
        elseif match(line, '^@@') != -1
            let lineNum = matchlist(line, '\v.* \+(\d*)')[1]
            let descIndex = i + 1
            while len(lines[descIndex]) == 1 && descIndex < len(lines) - 1
                let descIndex += 1
            endwhile
            if match(lines[descIndex], '^diff\|^@@') != -1
                let descIndex = i + 1
            endif
            cal add(locList, {'filename': file, 'lnum': lineNum, 'text': lines[descIndex]})
        endif
        let i += 1
    endwhile
    call setqflist(locList)
endfunction
command! -nargs=* Gdqf call QuickfixGitDiff('<args>')

function! SilentMake(...)
    if a:0 >= 1
        execute "silent! make! " . a:1
    else
        silent! make!
    endif
    redraw!
endfunction
com! -nargs=? Make call SilentMake(<f-args>)


" Tips
"
" Evaluate vimscript almost anywhere using <c-r>=
"
" Globally replace the word under the cursor with something else:
" :nn <leader>r :exec printf('%%s#\<%s\>#self.%s#g', expand('<cword>'), expand('<cword>'))<cr>
"
" Use substitute and eval together:
" '<,'>s/{{\([^}]\+\)}}/\=eval(submatch(1))/g
"
" You can basically get tab-specific working directories using :lcd.

if filereadable(expand('~/.vimrc.local'))
    source ~/.vimrc.local
endif
